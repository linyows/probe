name: Verify All Examples
description: |
  This workflow validates the workflows under examples/*.
  The following software is required: go, docker, mysqladmin, pg_isready

jobs:
# ------------------------------------------------------------------------
- name: Setup
  id: setup
  steps:
  - name: Go build
    uses: shell
    with:
      # needs cgo for go-sqlite3
      cmd: CGO_ENABLED=1 go build -ldflags="-s -w" -o probe ./cmd/probe/...
    test: status == 0
  - name: Pull httpbin images
    uses: shell
    with:
      cmd: docker pull kennethreitz/httpbin:latest
      timeout: 3m
    test: status == 0
  - name: Pull postgres images
    uses: shell
    with:
      cmd: docker pull postgres:16
      timeout: 3m
    test: status == 0
  - name: Pull mysql images
    uses: shell
    with:
      cmd: docker pull mysql:8.4
      timeout: 3m
    test: status == 0
  - name: Pull openssh images
    uses: shell
    with:
      cmd: docker pull linuxserver/openssh-server:version-10.2_p1-r0
      timeout: 3m
    test: status == 0
  - name: Pull mailpit images
    uses: shell
    with:
      cmd: docker pull axllent/mailpit:v1.28
      timeout: 3m
    test: status == 0
  - name: Pull greenmail images
    uses: shell
    with:
      cmd: docker pull greenmail/standalone:2.1.0
      timeout: 3m
    test: status == 0

# ------------------------------------------------------------------------
- name: Basic Workflow Tests
  id: basic
  needs: [setup]
  steps:
  - name: shell.yml
    uses: shell
    with:
      cmd: ./probe examples/shell.yml
    test: res.code == 0
    echo: "{{res.stdout}}"
  - name: fail.yml (expected to fail)
    uses: shell
    with:
      cmd: ./probe examples/fail.yml
    test: res.code == 1
    echo: "{{res.stdout}}"
  - name: realtime-print.yml
    uses: shell
    with:
      cmd: ./probe examples/realtime-print.yml
    test: res.code == 0
    echo: "{{res.stdout}}"
  - name: retry-literal.yml
    uses: shell
    with:
      cmd: ./probe examples/retry-literal.yml
    test: res.code == 0
    echo: "{{res.stdout}}"
  - name: skipif-literal.yml
    uses: shell
    with:
      cmd: ./probe examples/skipif-literal.yml
    test: res.code == 0
    echo: "{{res.stdout}}"
  - name: echo-literal.yml
    uses: shell
    with:
      cmd: ./probe examples/echo-literal.yml
    test: res.code == 0
    echo: "{{res.stdout}}"
  - name: timeout-literal.yml (expected to fail)
    uses: shell
    with:
      cmd: ./probe examples/timeout-literal.yml
    test: res.code == 1
    echo: "{{res.stdout}}"
  - name: needs-literal.yml (expected to fail)
    uses: shell
    with:
      cmd: ./probe examples/needs-literal.yml
    test: res.code == 1
  - name: truncate-print.yml
    uses: shell
    with:
      cmd: ./probe examples/truncate-print.yml
    test: res.code == 0
    echo: "{{res.stdout}}"
  - name: outputs-literal.yml
    uses: shell
    with:
      cmd: ./probe examples/outputs-literal.yml
    test: res.code == 0
    echo: "{{res.stdout}}"
  - name: yaml-shared.yml and yaml-alias.yml
    uses: shell
    with:
      cmd: ./probe examples/yaml-shared.yml,examples/yaml-alias.yml
    test: res.code == 0
    echo: "{{res.stdout}}"
  - name: nested-alias.yml
    uses: shell
    with:
      cmd: ./probe examples/nested-alias.yml
    test: res.code == 0
    echo: "{{res.stdout}}"
  - name: iteration-literal.yml
    uses: shell
    with:
      cmd: ./probe examples/iteration-literal.yml
    test: res.code == 0
    echo: "{{res.stdout}}"
  - name: repeat-literal.yml (expected to fail)
    uses: shell
    with:
      cmd: ./probe examples/repeat-literal.yml
    test: res.code == 1
    echo: "{{res.stdout}}"
  - name: embedded-job.yml
    uses: shell
    with:
      cmd: ./probe examples/embedded-job.yml
    test: res.code == 0
    echo: "{{res.stdout}}"
  - name: expr-functions.yml
    uses: shell
    with:
      cmd: ./probe examples/expr-functions.yml
    test: res.code == 0
    echo: "{{res.stdout}}"

# ------------------------------------------------------------------------
- name: HTTP Server Start
  id: http_server
  needs: [setup]
  steps:
  - name: Cleanup old HTTP container
    uses: shell
    with:
      cmd: docker stop probe-httpbin 2>/dev/null || true
    test: status == 0
  - name: Start HTTP server in background
    uses: shell
    with:
      background: true
      #cmd: go run github.com/mccutchen/go-httpbin/v2/cmd/go-httpbin@latest -host 127.0.0.1 -port 8080
      cmd: "docker run --rm -p 8080:80 --name probe-httpbin kennethreitz/httpbin:latest"
    test: status == -1
    outputs:
      http_pid: res.pid
      http_log: res.log
    echo: |
      PID: {{ res.pid }}
      Log: {{ res.log }}
  - name: Wait for HTTP server to be ready
    uses: http
    with:
      url: http://localhost:8080
      get: /get
    retry:
      max_attempts: 5
      interval: "1s"
      initial_delay: "2s"
    test: res.code == 200

- name: HTTP Workflow Tests
  id: http
  needs: [http_server]
  steps:
  - name: http.yml
    uses: shell
    with:
      cmd: ./probe examples/http.yml
    test: res.code == 0
    echo: "{{res.stdout}}"
  - name: Stop HTTP server
    uses: shell
    with:
      cmd: docker stop probe-httpbin
    test: status == 0

# ------------------------------------------------------------------------
- name: GRPC Servers Start
  id: grpc_server
  needs: [setup]
  steps:
  - name: Generate keys and protobuf
    uses: shell
    with:
      cmd: |
        ./testdata/gen.sh
        go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
        go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest
        cd grpc/testserver && \
          protoc --go_out=. --go-grpc_out=. ./pb/user_service.proto
    test: res.code == 0
  - name: Start GRPC server in background
    uses: shell
    with:
      background: true
      cmd: go run grpc/testserver/*.go
    test: status == -1
    outputs:
      grpc_pid: res.pid
      grpc_log: res.log
    echo: |
      PID: {{ res.pid }}
      Log: {{ res.log }}
  - name: Start GRPC server (TLS) in background
    uses: shell
    with:
      background: true
      cmd: |
        go run grpc/testserver/*.go -tls -port=50052 \
          -cert="./testdata/certs/server.crt" \
          -key="./testdata/certs/server.key"
    test: status == -1
    outputs:
      grpctls_pid: res.pid
      grpctls_log: res.log
    echo: |
      PID: {{ res.pid }}
      Log: {{ res.log }}

- name: GRPC Workflow Tests
  id: grpc
  needs: [grpc_server]
  steps:
  - name: grpc.yml
    uses: shell
    with:
      cmd: ./probe examples/grpc.yml
    test: res.code == 0
    echo: "{{res.stdout}}"
  - name: Stop GRPC server
    uses: shell
    with: # Use Process Group ID
      cmd: "kill -TERM -{{ outputs.grpc_pid }}"
    test: status == 0
  - name: Stop GRPC server with TLS
    uses: shell
    with: # Use Process Group ID
      cmd: "kill -TERM -{{ outputs.grpctls_pid }}"
    test: status == 0

# ------------------------------------------------------------------------
- name: SQLite Workflow Tests
  id: sqlite
  needs: [setup]
  steps:
  - name: sqlite.yml
    uses: shell
    with:
      cmd: ./probe examples/sqlite.yml
    test: res.code == 0
    echo: "{{res.stdout}}"

# ------------------------------------------------------------------------
- name: Postgres Server Start
  id: postgres_container
  needs: [setup]
  steps:
  - name: Cleanup old PostgreSQL container
    uses: shell
    with:
      cmd: docker stop probe-postgres 2>/dev/null || true
    test: status == 0
  - name: Start PostgreSQL container
    uses: shell
    with:
      background: true
      cmd: |
        docker run --rm -p 15432:5432 --name probe-postgres --tmpfs /var/lib/postgres \
          -e POSTGRES_USER=probe -e POSTGRES_PASSWORD=password -e POSTGRES_DB=postgres postgres:16
    test: status == -1
    outputs:
      postgres_pid: res.pid
      postgres_log: res.log
    echo: |
      PID: {{ res.pid }}
      Log: {{ res.log }}
  - name: Wait for PostgreSQL server to be ready
    uses: shell
    with:
      cmd: pg_isready -h 127.0.0.1 -p 15432 -U probe -d postgres -q
    retry:
      max_attempts: 15
      interval: "3s"
      initial_delay: "2s"
    test: res.code == 0

- name: PostgreSQL Workflow Tests
  needs: [postgres_container]
  id: postgres
  steps:
  - name: postgres.yml
    uses: shell
    with:
      cmd: |
        POSTGRES_PORT=15432 POSTGRES_USER=probe POSTGRES_PASS=password \
          ./probe examples/postgres.yml
    test: res.code == 0
    echo: "{{res.stdout}}"
  - name: Stop PostgreSQL container
    uses: shell
    with:
      cmd: docker stop probe-postgres
    test: status == 0

# ------------------------------------------------------------------------
- name: MySQL Server Start
  id: mysql_container
  needs: [setup]
  steps:
  - name: Cleanup old MySQL container
    uses: shell
    with:
      cmd: docker stop probe-mysql 2>/dev/null || true
    test: status == 0
  - name: Start MySQL container
    uses: shell
    with:
      background: true
      cmd: |
        docker run --rm -p 13306:3306 --name probe-mysql --tmpfs /var/lib/mysql \
          -e MYSQL_ROOT_PASSWORD=password -e MYSQL_DATABASE=mysql mysql:8.4
    test: status == -1
    outputs:
      mysql_pid: res.pid
      mysql_log: res.log
    echo: |
      PID: {{ res.pid }}
      Log: {{ res.log }}
  - name: Wait for MySQL server to be ready
    uses: shell
    with:
      cmd: MYSQL_PWD=password mysqladmin ping -uroot -h127.0.0.1 -P13306
    retry:
      max_attempts: 15
      interval: "3s"
      initial_delay: "2s"
    test: res.code == 0

- name: MySQL Workflow Tests
  needs: [mysql_container]
  id: mysql
  steps:
  - name: mysql.yml
    uses: shell
    with:
      cmd: |
        MYSQL_PORT=13306 MYSQL_PASS=password \
          ./probe examples/mysql.yml
    test: res.code == 0
    echo: "{{res.stdout}}"
  - name: Stop MySQL container
    uses: shell
    with:
      cmd: docker stop probe-mysql
    test: status == 0

# ------------------------------------------------------------------------
- name: SSH Server Start
  id: ssh_container
  needs: [setup]
  steps:
  - name: Cleanup old SSH container
    uses: shell
    with:
      cmd: docker stop probe-ssh 2>/dev/null || true
    test: status == 0
  - name: Generate SSH test key
    uses: shell
    with:
      cmd: |
        rm -rf ./testdata/ssh
        mkdir -p ./testdata/ssh
        ssh-keygen -t rsa -b 2048 -f ./testdata/ssh/test_key -N "" -C "probe-test"
        chmod 600 ./testdata/ssh/test_key
        chmod 644 ./testdata/ssh/test_key.pub
    test: res.code == 0
  - name: Start SSH container
    uses: shell
    with:
      background: true
      cmd: |
        docker run --rm -p 2222:2222 --name probe-ssh \
          -e PUID=1000 \
          -e PGID=1000 \
          -e USER_NAME=probe \
          -e SUDO_ACCESS=true \
          -e PUBLIC_KEY="$(cat ./testdata/ssh/test_key.pub)" \
          linuxserver/openssh-server:version-10.2_p1-r0
    test: status == -1
    outputs:
      ssh_pid: res.pid
      ssh_log: res.log
    echo: |
      PID: {{ res.pid }}
      Log: {{ res.log }}
  - name: Wait for SSH server to be ready
    uses: shell
    with:
      cmd: |
        ssh -i ./testdata/ssh/test_key -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null \
          -p 2222 probe@127.0.0.1 "echo ready"
    retry:
      max_attempts: 30
      interval: "3s"
      initial_delay: "5s"
    test: res.code == 0

- name: SSH Workflow Tests
  needs: [ssh_container]
  id: ssh
  steps:
  - name: ssh.yml
    uses: shell
    with:
      cmd: |
        SSH_HOST=127.0.0.1 SSH_PORT=2222 SSH_USER=probe \
          SSH_KEY_FILE=./testdata/ssh/test_key \
          ./probe examples/ssh.yml
    test: res.code == 0
    echo: "{{res.stdout}}"
  - name: Stop SSH container
    uses: shell
    with:
      cmd: docker stop probe-ssh
    test: status == 0

# ------------------------------------------------------------------------
- name: SMTP Server Start
  id: smtp_container
  needs: [setup]
  steps:
  - name: Cleanup old SMTP container
    uses: shell
    with:
      cmd: docker stop probe-smtp 2>/dev/null || true
    test: status == 0
  - name: Start SMTP container
    uses: shell
    with:
      background: true
      cmd: |
        docker run --rm -p 1025:1025 -p 8025:8025 --name probe-smtp \
          axllent/mailpit:v1.28
    test: status == -1
    outputs:
      smtp_pid: res.pid
      smtp_log: res.log
    echo: |
      PID: {{ res.pid }}
      Log: {{ res.log }}
  - name: Wait for SMTP server to be ready
    uses: http
    with:
      url: http://localhost:8025
      get: /api/v1/info
    retry:
      max_attempts: 15
      interval: "2s"
      initial_delay: "2s"
    test: res.code == 200

- name: SMTP Workflow Tests
  needs: [smtp_container]
  id: smtp
  steps:
  - name: smtp.yml
    uses: shell
    with:
      cmd: |
        SMTP_ADDR=localhost:1025 FROM_ADDR=sender@example.com \
          TO_ADDR=recipient@example.com \
          ./probe examples/smtp.yml
    test: res.code == 0
    echo: "{{res.stdout}}"
  - name: Stop SMTP container
    uses: shell
    with:
      cmd: docker stop probe-smtp
    test: status == 0

# ------------------------------------------------------------------------
- name: IMAP Server Start
  id: imap_container
  needs: [setup]
  steps:
  - name: Cleanup old IMAP container
    uses: shell
    with:
      cmd: docker stop probe-imap 2>/dev/null || true
    test: status == 0
  - name: Start IMAP container
    uses: shell
    with:
      background: true
      cmd: |
        docker run --rm -p 3025:3025 -p 3143:3143 -p 3993:3993 -p 8081:8080 --name probe-imap \
          -e GREENMAIL_OPTS='-Dgreenmail.setup.test.all -Dgreenmail.hostname=0.0.0.0 -Dgreenmail.users=test:password@example.com' \
          greenmail/standalone:2.1.0
    test: status == -1
    outputs:
      imap_pid: res.pid
      imap_log: res.log
    echo: |
      PID: {{ res.pid }}
      Log: {{ res.log }}
  - name: Wait for IMAP server to be ready
    uses: http
    with:
      url: http://localhost:8081
      get: /api/service/readiness
    retry:
      max_attempts: 15
      interval: "2s"
      initial_delay: "3s"
    test: res.code == 200

- name: IMAP Workflow Tests
  needs: [imap_container]
  id: imap
  steps:
  - name: imap.yml
    uses: shell
    with:
      cmd: |
        MAIL_HOST=localhost MAIL_PORT=3143 \
          MAIL_USER=test MAIL_PASS=password \
          MAIL_TO=test@example.com \
          MAIL_SETUP=true SMTP_HOST=localhost SMTP_PORT=3025 \
          TLS_ENABLED=false \
          SKIP_SEARCH_TESTS=true \
          ./probe examples/imap.yml
    test: res.code == 0
    echo: "{{res.stdout}}"
  - name: Stop IMAP container
    uses: shell
    with:
      cmd: docker stop probe-imap
    test: status == 0

# ------------------------------------------------------------------------
- name: Browser Tests
  id: browser
  needs: [setup]
  steps:
  - name: browser.yml
    uses: shell
    with:
      cmd: ./probe examples/browser.yml
      timeout: 2m
    test: res.code == 0
    echo: "{{res.stdout}}"
